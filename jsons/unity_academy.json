{
  "add_impulse_force": "<div><h4>add_impulse_force(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Add an impulse force on the Rigidbody attached on the GameObject, &lt;b&gt;using its mass&lt;/b&gt;.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "add_vector": "<div><h4>add_vector(vectorA: Vector3, vectorB: Vector3) → {Vector3}</h4><div class=\"description\"><p>Add two 3D vectors together.</p></div></div>",
  "apply_rigidbody": "<div><h4>apply_rigidbody(gameObjectIdentifier: GameObjectIdentifier) → {void}</h4><div class=\"description\"><p>Apply rigidbody (2D or 3D based on the current dimension mode) to the given game object to use Unity's physics engine&lt;br&gt;  \n&lt;br&gt;&lt;br&gt;All other functions under the Physics - Rigidbody category require calling this function first on the applied game objects.  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/Rigidbody.html (For 3D Mode) or  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/Rigidbody2D.html (For 2D Mode)</p></div></div>",
  "copy_position": "<div><h4>copy_position(from: GameObjectIdentifier, to: GameObjectIdentifier, delta_x: number, delta_y: number, delta_z: number) → {void}</h4><div class=\"description\"><p>Copy the position values from one GameObject to another GameObject along with delta values.&lt;br&gt;&lt;br&gt;  \nSet the delta parameters to <code>Infinity</code> or <code>-Infinity</code> to remain the position of the destination GameObject on the corresponding axis unaffected.&lt;br&gt;</p></div></div>",
  "copy_rotation": "<div><h4>copy_rotation(from: GameObjectIdentifier, to: GameObjectIdentifier, delta_x: number, delta_y: number, delta_z: number) → {void}</h4><div class=\"description\"><p>Copy the rotation values (Euler angles) from one GameObject to another GameObject along with delta values.&lt;br&gt;&lt;br&gt;  \nSet the delta parameters to <code>Infinity</code> or <code>-Infinity</code> to remain the rotation of the destination GameObject on the corresponding axis unaffected.&lt;br&gt;</p></div></div>",
  "copy_scale": "<div><h4>copy_scale(from: GameObjectIdentifier, to: GameObjectIdentifier, delta_x: number, delta_y: number, delta_z: number) → {void}</h4><div class=\"description\"><p>Copy the scale values from one GameObject to another GameObject along with delta values.&lt;br&gt;&lt;br&gt;  \nSet the delta parameters to <code>Infinity</code> or <code>-Infinity</code> to remain the scale of the destination GameObject on the corresponding axis unaffected.&lt;br&gt;</p></div></div>",
  "cross": "<div><h4>cross(vectorA: Vector3, vectorB: Vector3) → {Vector3}</h4><div class=\"description\"><p>Calcuate the cross product of two 3D vectors.</p></div></div>",
  "delta_time": "<div><h4>delta_time() → {number}</h4><div class=\"description\"><p>Returns the value of Time.deltaTime in Unity ( roughly saying it's about <code>1 / instant frame rate</code> )&lt;br&gt;  \nThis should be useful when implementing timers or constant speed control in Update function.&lt;br&gt;  \nFor example:  <pre><code>function update(gameObject){  \n    const move_speed = 3;  \n    translate_world(gameObject, 0, 0, move_speed * delta_time());  \n}  </code></pre>  \nBy assigning the above code to a GameObject with <code>set_update</code>, that GameObject will move in a constant speed of 3 units along world +Z axis, ignoring the affect of unstable instant frame rate.  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Time-deltaTime.html</p></div></div>",
  "destroy": "<div><h4>destroy(gameObjectIdentifier: GameObjectIdentifier) → {void}</h4><div class=\"description\"><p>Remove a GameObject&lt;br&gt;  \nNote that this won't remove the GameObject immediately, the actual removal will happen at the end of the current main cycle loop.&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Object.Destroy.html</p></div></div>",
  "dot": "<div><h4>dot(vectorA: Vector3, vectorB: Vector3) → {number}</h4><div class=\"description\"><p>Calcuate the dot product of two 3D vectors.</p></div></div>",
  "gameobject_distance": "<div><h4>gameobject_distance(gameObjectIdentifier_A: GameObjectIdentifier, gameObjectIdentifier_B: GameObjectIdentifier) → {number}</h4><div class=\"description\"><p>Calcuate the distance between two GameObjects, based on each other's position</p></div></div>",
  "get_angular_velocity": "<div><h4>get_angular_velocity(gameObjectIdentifier: GameObjectIdentifier) → {undefined}</h4><div class=\"description\"><p>Returns the angular velocity of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.  \n&lt;br&gt;&lt;br&gt;&lt;b&gt;2D Mode Special: &lt;/b&gt;In 2D mode there is no angular velocity on X nor Y axis, so in the first two elements for the returned array will always be zero.</p></div></div>",
  "get_custom_prop": "<div><h4>get_custom_prop(gameObjectIdentifier: GameObjectIdentifier, propName: string) → {any}</h4><div class=\"description\"><p>Get the value of a custom property with its name on a GameObject</p></div></div>",
  "get_key": "<div><h4>get_key(keyCode: string) → {boolean}</h4><div class=\"description\"><p>When user presses a key on the keyboard or mouse button, this function will return true in every frame that the key is still being pressed and false otherwise.  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Input.GetKey.html</p></div></div>",
  "get_key_down": "<div><h4>get_key_down(keyCode: string) → {boolean}</h4><div class=\"description\"><p>When user presses a key on the keyboard or mouse button, this function will return true only at the frame when the key is just pressed down and return false afterwards.  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Input.GetKeyDown.html</p></div></div>",
  "get_key_up": "<div><h4>get_key_up(keyCode: string) → {boolean}</h4><div class=\"description\"><p>When user releases a pressed key on the keyboard or mouse button, this function will return true only at the frame when the key is just released up and return false otherwise.  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Input.GetKeyUp.html</p></div></div>",
  "get_main_camera_following_target": "<div><h4>get_main_camera_following_target() → {GameObjectIdentifier}</h4><div class=\"description\"><p>Get the main camera following target GameObject (an invisible GameObject) to use it to control the position of the main camera with the default camera controller.&lt;br&gt;&lt;br&gt;  \n&lt;b&gt;In 3D mode&lt;/b&gt;, the default camera controller behaves as third-person camera controller, and the center to follow is the following target GameObject. Also, Unity Academy will automatically set the rotation of this \"following target\" to the same rotation as the current main camera's rotation to let you get the main camera's rotation.&lt;br&gt;  \n&lt;b&gt;In 2D mode&lt;/b&gt;, the default camera controller will follow the target GameObject to move, along with a position delta value that you can adjust with the arrow keys on your keyboard.&lt;br&gt;&lt;br&gt;  \nThe main camera following target GameObject is a primitive GameObject. This means that you are not allowed to destroy it and/or instantiate it during runtime. Multiple calls to this function will return GameObject identifiers that refer to the same primitive GameObject.&lt;br&gt;  \n&lt;br&gt;  \n&lt;br&gt;&lt;b&gt;If default main camera controllers are disabled (you have called <code>request_for_main_camera_control</code>), then the following target GameObject is useless.&lt;/b&gt;</p></div></div>",
  "get_mass": "<div><h4>get_mass(gameObjectIdentifier: GameObjectIdentifier) → {number}</h4><div class=\"description\"><p>Returns the mass of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "get_position": "<div><h4>get_position(gameObjectIdentifier: GameObjectIdentifier) → {undefined}</h4><div class=\"description\"><p>Returns the world position of a given GameObject</p></div></div>",
  "get_rotation_euler": "<div><h4>get_rotation_euler(gameObjectIdentifier: GameObjectIdentifier) → {undefined}</h4><div class=\"description\"><p>Returns the world Euler angle rotation of a given GameObject</p></div></div>",
  "get_scale": "<div><h4>get_scale(gameObjectIdentifier: GameObjectIdentifier) → {undefined}</h4><div class=\"description\"><p>Returns the scale (size factor) of a given GameObject  \n&lt;br&gt;  \nBy default the scale of a GameObject is (1, 1, 1)</p></div></div>",
  "get_velocity": "<div><h4>get_velocity(gameObjectIdentifier: GameObjectIdentifier) → {undefined}</h4><div class=\"description\"><p>Returns the velocity of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "get_x": "<div><h4>get_x(vector: Vector3) → {number}</h4><div class=\"description\"><p>Get the X component of a 3D vector</p></div></div>",
  "get_y": "<div><h4>get_y(vector: Vector3) → {number}</h4><div class=\"description\"><p>Get the Y component of a 3D vector</p></div></div>",
  "get_z": "<div><h4>get_z(vector: Vector3) → {number}</h4><div class=\"description\"><p>Get the Z component of a 3D vector</p></div></div>",
  "gui_button": "<div><h4>gui_button(text: string, x: number, y: number, fontSize: number, onClick: Function) → {void}</h4><div class=\"description\"><p>Make a button on the screen with given &lt;b&gt;screen space position&lt;/b&gt; in the current frame. When user clicks the button, the <code>onClick</code> function will be called.&lt;br&gt;  \nThe origin of screen space is upper-left corner and the positive Y direction is downward.&lt;br&gt;  \nThe drawn button will only last for one frame. You should put this under the <code>Update</code> function (or a function that is called by the <code>Update</code> function) to keep the button stays in every frame.  \n&lt;br&gt;  \n&lt;br&gt;  \nIf this function is called by a lifecycle event function, then the <code>onClick</code> function in the fourth parameter could also be considered as a lifecycle event function.&lt;br&gt;  \nThis means that you can use other functions from this module inside the <code>onClick</code> function, even though the functions are not under the <code>Outside Lifecycle</code> category.&lt;br&gt;  \nFor example, the code piece below  <pre><code>import {init_unity_academy_3d, set_start, set_update, instantiate, gui_button, set_position }  \nfrom \"unity_academy\";  \ninit_unity_academy_3d();  \n  \nconst cube = instantiate(\"cube\");  \n  \nconst cube_update = (gameObject) =&gt; {  \n  gui_button(\"Button\", 1000, 300, ()=&gt;  \n    set_position(gameObject, 0, 10, 6) // calling set_position inside the onClick function  \n  );  \n};  \n\nset_update(cube, cube_update);  </code></pre>  \nis correct.&lt;br&gt;</p></div></div>",
  "gui_label": "<div><h4>gui_label(content: string, x: number, y: number, fontSize: number) → {void}</h4><div class=\"description\"><p>Draw a text (string) on the screen with given &lt;b&gt;screen space position&lt;/b&gt; in the current frame.&lt;br&gt;  \nThe origin of screen space is upper-left corner and the positive Y direction is downward.&lt;br&gt;  \nThe drawn text will only last for one frame. You should put this under the <code>Update</code> function (or a function that is called by the <code>Update</code> function) to keep the text stays in every frame.&lt;br&gt;</p></div></div>",
  "init_unity_academy_2d": "<div><h4>init_unity_academy_2d() → {void}</h4><div class=\"description\"><p>Load and initialize Unity Academy WebGL player and set it to 2D mode. All other functions (except Maths functions) in this module requires calling this function or init_unity_academy_3d first.&lt;br&gt;  \nI recommand you just call this function at the beginning of your Source Unity program under the 'import' statements.</p></div></div>",
  "init_unity_academy_3d": "<div><h4>init_unity_academy_3d() → {void}</h4><div class=\"description\"><p>Load and initialize Unity Academy WebGL player and set it to 3D mode. All other functions (except Maths functions) in this module requires calling this function or init_unity_academy_2d first.&lt;br&gt;  \nI recommand you just call this function at the beginning of your Source Unity program under the 'import' statements.</p></div></div>",
  "instantiate": "<div><h4>instantiate(prefab_name: string) → {GameObjectIdentifier}</h4><div class=\"description\"><p>Creates a new GameObject from an existing Prefab&lt;br&gt;  \n&lt;br&gt;  \n&lt;b&gt;3D mode only&lt;/b&gt;&lt;br&gt;  \n&lt;br&gt;  \nAvailable Prefab Information: &lt;a href = 'https://unity-academy.s3.ap-southeast-1.amazonaws.com/webgl_assetbundles/prefab_info.html' rel=\"noopener noreferrer\" target=\"_blank\"&gt;Click Here&lt;/a&gt;</p></div></div>",
  "instantiate_empty": "<div><h4>instantiate_empty() → {GameObjectIdentifier}</h4><div class=\"description\"><p>Creates a new empty GameObject.&lt;br&gt;  \n&lt;br&gt;  \nAn empty GameObject is invisible and only have transform properties by default.&lt;br&gt;  \nYou may use the empty GameObject to run some general game management code or use the position of the empty GameObject to represent a point in the scene that the rest of your codes can access and utilize.</p></div></div>",
  "instantiate_sprite": "<div><h4>instantiate_sprite(sourceImageUrl: string) → {GameObjectIdentifier}</h4><div class=\"description\"><p>Creates a new 2D Sprite GameObject from an online image.&lt;br&gt;  \nThe Sprite GameObject has a BoxCollider2D that matches its size by default. You may use <code>remove_collider_components</code> function to remove the default collider.&lt;br&gt;&lt;br&gt;  \nNote that Unity Academy will use a HTTP GET request to download the image, which means that the HTTP response from the URL must allows CORS.&lt;br&gt;&lt;br&gt;  \n&lt;br&gt;&lt;b&gt;2D mode only&lt;/b&gt;</p></div></div>",
  "look_at": "<div><h4>look_at(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Makes the GameObject \"Look At\" a given position.&lt;br&gt;  \n&lt;b&gt;3D mode only&lt;/b&gt;&lt;br&gt;  \n&lt;br&gt;  \nThe +Z direction of the GameObject (which denotes forward in Unity's conventions) will pointing to the given position.&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see https://docs.unity3d.com/ScriptReference/Transform.LookAt.html&lt;br&gt;</p></div></div>",
  "magnitude": "<div><h4>magnitude(vector: Vector3) → {number}</h4><div class=\"description\"><p>Calcuate the magnitude of a vector</p></div></div>",
  "normalize": "<div><h4>normalize(vector: Vector3) → {Vector3}</h4><div class=\"description\"><p>Normalize a vector. The returned vector will have the same direction as the original vector but have a magnitude of 1.</p></div></div>",
  "on_collision_enter": "<div><h4>on_collision_enter(gameObjectIdentifier: GameObjectIdentifier, eventFunction: Function) → {void}</h4><div class=\"description\"><p>Set the lifecycle event function that will be called when the collider on this GameObject just starting colliding with another collider.&lt;br&gt;  \n&lt;br&gt;  \nThe given function should contain two parameters. The first parameter refers to the binded GameObject and the second parameter refers to the other GameObject that collides with the binded GameObject (both parameters are GameObject identifiers).&lt;br&gt;  \nFor example: <code>const myFunction = (self, other) =&gt; {...};</code>  \n&lt;br&gt;  \nNote that for collision detaction to happen, for the two colliding GameObjects, at least one GameObject should have a Rigidbody / Rigidbody2D component (called <code>apply_rigidbody</code> on the GameObject).  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/Collider.OnCollisionEnter.html (For 3D Mode) or  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionEnter2D.html (For 2D Mode)</p></div></div>",
  "on_collision_exit": "<div><h4>on_collision_exit(gameObjectIdentifier: GameObjectIdentifier, eventFunction: Function) → {void}</h4><div class=\"description\"><p>Set the lifecycle event function that will be called when the collider on this GameObject just stops colliding with another collider.&lt;br&gt;  \n&lt;br&gt;  \nThe given function should contain two parameters. The first parameter refers to the binded GameObject and the second parameter refers to the other GameObject that collides with the binded GameObject (both parameters are GameObject identifiers).&lt;br&gt;  \nFor example: <code>const myFunction = (self, other) =&gt; {...};</code>  \n&lt;br&gt;  \nNote that for collision detaction to happen, for the two colliding GameObjects, at least one GameObject should have a Rigidbody / Rigidbody2D component (called <code>apply_rigidbody</code> on the GameObject).  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionExit.html (For 3D Mode) or  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionExit2D.html (For 2D Mode)</p></div></div>",
  "on_collision_stay": "<div><h4>on_collision_stay(gameObjectIdentifier: GameObjectIdentifier, eventFunction: Function) → {void}</h4><div class=\"description\"><p>Set the lifecycle event function that will be called per frame when the collider on this GameObject is colliding with another collider.&lt;br&gt;  \n&lt;br&gt;  \nThe given function should contain two parameters. The first parameter refers to the binded GameObject and the second parameter refers to the other GameObject that collides with the binded GameObject (both parameters are GameObject identifiers).&lt;br&gt;  \nFor example: <code>const myFunction = (self, other) =&gt; {...};</code>  \n&lt;br&gt;  \nNote that for collision detaction to happen, for the two colliding GameObjects, at least one GameObject should have a Rigidbody / Rigidbody2D component (called <code>apply_rigidbody</code> on the GameObject).  \n&lt;br&gt;  \n&lt;br&gt;  \nFor more information, see  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/Collider.OnCollisionStay.html (For 3D Mode) or  \n&lt;br&gt;https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnCollisionStay2D.html (For 2D Mode)</p></div></div>",
  "play_animator_state": "<div><h4>play_animator_state(gameObjectIdentifier: GameObjectIdentifier, animatorStateName: string) → {void}</h4><div class=\"description\"><p>Plays an Unity animation state with given name on the GameObject's animator. Note that not all game objects have Unity animations. You should ask the people who provided you the prefab asset bundle for available animation names assigned to the prefab.&lt;br&gt;&lt;br&gt;  \nIf you provide an invalid animator state name, this function will not take effect.&lt;br&gt;&lt;br&gt;  \n&lt;b&gt;3D mode only&lt;/b&gt;&lt;br&gt;&lt;br&gt;  \n[For Prefab Authors] Please follow these conventions if you are making humanoid prefabs (for example: any human-like characters): Name the standing animation state as \"Idle\" and name the walking animation state as \"Walk\" in Unity Animator.&lt;br&gt;</p></div></div>",
  "point_distance": "<div><h4>point_distance(pointA: Vector3, pointB: Vector3) → {number}</h4><div class=\"description\"><p>Calcuate the distance between two 3D points</p></div></div>",
  "remove_collider_components": "<div><h4>remove_collider_components(gameObjectIdentifier: GameObjectIdentifier) → {void}</h4><div class=\"description\"><p>Removes all collider components directly attached on the given GameObject by default.&lt;br&gt;  \n&lt;br&gt;  \nYou can use this function on GameObjects those you don't want them to collide with other GameObjects.&lt;br&gt;  \nFor example, you may use this on the background image sprite GameObject in 2D scene.</p></div></div>",
  "request_for_main_camera_control": "<div><h4>request_for_main_camera_control() → {GameObjectIdentifier}</h4><div class=\"description\"><p>Request for main camera control and get a GameObject identifier that can directly be used to control the main camera's position and rotation.&lt;br&gt;  \n&lt;br&gt;  \nWhen you request for the direct control over main camera with this function, the default camera controllers will be disabled, thus the GameObject identifier returned by <code>get_main_camera_following_target</code> will become useless, as you can no longer use the default main camera controllers.&lt;br&gt;  \n&lt;br&gt;  \nThis function is for totally customizing the position and rotation of the main camera. If you'd like to simplify the camera controlling with the help of the default camera controllers in Unity Academy, please consider use <code>get_main_camera_following_target</code> function.&lt;br&gt;</p></div></div>",
  "rotate_world": "<div><h4>rotate_world(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Rotates a GameObject with given x, y and z values (Euler angle)</p></div></div>",
  "same_gameobject": "<div><h4>same_gameobject(first: GameObjectIdentifier, second: GameObjectIdentifier) → {boolean}</h4><div class=\"description\"><p>Determines whether two GameObject identifiers refers to the same GameObject.</p></div></div>",
  "scale_vector": "<div><h4>scale_vector(vector: Vector3, factor: number) → {Vector3}</h4><div class=\"description\"><p>Scales a 3D vector with the given factor.</p></div></div>",
  "set_angular_drag": "<div><h4>set_angular_drag(gameObjectIdentifier: GameObjectIdentifier, value: number) → {void}</h4><div class=\"description\"><p>Set the angular drag (similar to an air resistance that affects angular velocity) the rigidbody attached on the game object.&lt;br&gt;  \nBy default the angular drag is 0.05  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "set_angular_velocity": "<div><h4>set_angular_velocity(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Set the angular velocity of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.  \n&lt;br&gt;&lt;br&gt;&lt;b&gt;2D Mode Special: &lt;/b&gt;In 2D mode there is no angular velocity on X nor Y axis, so the value of the first two parameters for this function is ignored.</p></div></div>",
  "set_custom_prop": "<div><h4>set_custom_prop(gameObjectIdentifier: GameObjectIdentifier, propName: string, value: any) → {void}</h4><div class=\"description\"><p>Set a custom property with name and value on a GameObject</p></div></div>",
  "set_drag": "<div><h4>set_drag(gameObjectIdentifier: GameObjectIdentifier, value: number) → {void}</h4><div class=\"description\"><p>Set the drag (similar to air resistance) the rigidbody attached on the game object.&lt;br&gt;  \nBy default the drag is zero  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "set_mass": "<div><h4>set_mass(gameObjectIdentifier: GameObjectIdentifier, mass: number) → {void}</h4><div class=\"description\"><p>Set the mass of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "set_position": "<div><h4>set_position(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Set the world position of a given GameObject</p></div></div>",
  "set_rotation_euler": "<div><h4>set_rotation_euler(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Set the world rotation of a given GameObject with given Euler angle rotation.</p></div></div>",
  "set_scale": "<div><h4>set_scale(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Set the scale (size) of a given GameObject  \n&lt;br&gt;  \nBy default the scale of a GameObject is (1, 1, 1). Changing the scale of a GameObject along one axis will lead to a stretch or squeeze of the GameObject along that axis.</p></div></div>",
  "set_start": "<div><h4>set_start(gameObjectIdentifier: GameObjectIdentifier, startFunction: Function) → {void}</h4><div class=\"description\"><p>Sets the Start function of a given GameObject</p></div></div>",
  "set_update": "<div><h4>set_update(gameObjectIdentifier: GameObjectIdentifier, updateFunction: Function) → {void}</h4><div class=\"description\"><p>Sets the Update function of a given GameObject</p></div></div>",
  "set_use_gravity": "<div><h4>set_use_gravity(gameObjectIdentifier: GameObjectIdentifier, useGravity: boolean) → {void}</h4><div class=\"description\"><p>Set whether the rigidbody attached on the game object should calculate for gravity.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "set_velocity": "<div><h4>set_velocity(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Set the (linear) velocity of the rigidbody attached on the game object.  \n&lt;br&gt;&lt;br&gt;Usage of all physics functions under the Physics - Rigidbody category requires calling <code>apply_rigidbody</code> first on the applied game objects.</p></div></div>",
  "translate_local": "<div><h4>translate_local(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Moves a GameObject with given x, y and z values, &lt;b&gt;with respect to its local space&lt;/b&gt;.&lt;br&gt;  \nThe current rotation of the GameObject will affect the real direction of movement.&lt;br&gt;  \nIn Unity, usually, the direction of +Z axis denotes forward.</p></div></div>",
  "translate_world": "<div><h4>translate_world(gameObjectIdentifier: GameObjectIdentifier, x: number, y: number, z: number) → {void}</h4><div class=\"description\"><p>Moves a GameObject with given x, y and z values</p></div></div>",
  "vector3": "<div><h4>vector3(x: number, y: number, z: number) → {Vector3}</h4><div class=\"description\"><p>Create a 3D vector</p></div></div>",
  "zero_vector": "<div><h4>zero_vector() → {Vector3}</h4><div class=\"description\"><p>Get the zero vector</p></div></div>"
}